My Current Projects
A slightly lengthy outline of my current projects.
blog/my-current-projects/stick-figure-on-a-computer.webp
A crudely drawn stick figure using a computer
2024-03-11-18-42-26

https://cdt.social/@clayton/112079483596346070
<h1>My Current Projects</h1>
<p>I was talking to <a href="https://haydenshuker.com" target="_BLANK">Hayden Shuker</a> yesterday and I realized I haven’t really outlined any of my current projects on this blog, so I shall.</p>
<h2>This Blog</h2>
	<p>Over spring break, I rewrote my blog to be statically generated with OCaml and untethered from NixOS’s configuration. In the following diagram, you may see how I made this decision:</p>
	
<figure><img src="old-vs-new-blog-process.webp" alt="Funny diagram describing the old vs new process."><figcaption>Previously, to create a new blog post, I would have to copy the standard HTML header, edit the header for the blog post, write the blog post in HTML, add the post to the RSS feed, add the post to the sitemap, commit and push the changes to GitHub, ssh into the server computer, paste the new revision ID into the NixOS configuration, rebuild, copy the new hash from the failed build, paste the hash into the NixOS configuration, rebuild, post a thread for comments on mastodon, add the mastodon thread ID for comments, commit and push the changes to GitHub, paste the new revision ID into the NixOS configuration, rebuild, copy the new hash from the failed build, paste the hash into the NixOS configuration, and rebuild. Now, I just add a folder with the metadata, HTML, and assets, commit and push  the changes to GitHub, add the mastodon thread ID for comments, and commit and push the changes to GitHub.</figcaption></figure>

<p>I chose OCaml because it can run like an interpreted language while still having types, and I thought I learned it in college last semester (I forgot). In the following diagram, you will understand why a compiled language is unnecessary:</p>

<figure><img src="why-ocaml.webp" alt="Short diagram explaining why an interpreted language like OCaml"><figcaption>When using a compiled language to make a static site generator, you first have to compile the static site generator and then run it, but since you only need to run it once, you need to compile every time you use it. With an interpreted language, the program just runs, which will almost always be faster than compiling and then running simply because of less layers in-between.</figcaption></figure>

<p>Unfortunately, you may have noticed that all the blog posts became inaccessible (shoutout to <a href="https://haydenshuker.com" target="_BLANK">Hayden</a> for notifying me). That is because of this fun little line, <code>Sys.mkdir "www" 777</code>. The "777" is supposed to make the "www" folder, which stores all the content for the website, accessible to all users of the systems - including the system user, nginx, that serves the website to users. "777" refers to the "unix?" command <code>chmod 777 <file></code> to make things fun and quirky. Apparently, by default, the "777" in chmod is in octal (base 8 instead of normal base 10 numbers). So, the "777", in normal numbers, is actually 511. Fortunately, OCaml does not randomly change the base of numbers depending on the function, but that means that "777" was not the correct input into <code>Sys.mkdir "www"</code> for the desired output (the correct input is "0o777" to make it octal) and I got folders with wonky permissions, somehow making all the website’s files except blog posts publicly accessible. You may wonder how I did not catch this mistake, but the answer is quite simple: I programmed the website on Windows, which ignores Unix’s funny file permissions, and it was really <a href="https://stackoverflow.com/questions/70633829/create-directory-when-it-does-not-exist" target="_BLANK">Stack Overflow</a>’s fault if you really think about it:</p>

<figure><img src="/blog/my-current-projects/stack-overflow-wrong-mkdir-ocaml.png" alt="A stack overflow answer saying to write 777 with a comment by Adam Dingle saying that’s wrong and to instead use 0o777"><figcaption>A stack overflow answer saying to write 777 with a comment by Adam Dingle saying that’s wrong and to instead use 0o777</figcaption></figure>

<p>If only I read <a href="https://stackoverflow.com/users/4034070/adam-dingle" target="_BLANK">Adam Dingle</a>’s comment.</p>

<p>Now that everything’s fixed, I’m currently writing this with my new workflow, HTML in Google Docs:</p>

<figure><img src="/blog/my-current-projects/google-doc-html.png" alt="The previous figure written in Google Docs in HTML format"><figcaption>The previous figure written in Google Docs in HTML format</figcaption></figure>

<p>Seems to be working nicely, despite it looking cursed.</p>
<h2>Tutor Engine</h2>
	<p>I’m starting a startup based on my work on a language learning app for the past 4 years. I finished developing a prototype last December. After testing the prototype with my brother and my dad and getting some feedback from some professors, I’m confident in the method. The prototype though is ugly, unintuitive, doesn’t work on mobile, and too reliant on alpha-stage open source projects. So, I’m rewriting it in <a href="https://flutter.dev/" target="_BLANK">Flutter</a>. For an end user, the interface will simply be: choose some books, TV shows, movies, language exams, etc. as their next learning goals, receive an automatically generated "shortest path" to their goal, press "study", receive precise instruction and minimal immersive exercises based on a simple & tunable <a href="https://en.wikipedia.org/wiki/Spaced_repetition" target="_BLANK">spaced repetition algorithm</a>, exit "study" at any time, receive cool screen precisely documenting your progress.</p>
<h2>Workspace</h2>
	<p>I was previously writing a GUI-based programming language to solve the problem of compilers abstracting away machine code too much. In a way, programming in a programming language is more like programming a program that programs machine code. So, the idea of the programming language was to show what the resulting machine code would be at every step, but macro-like interactions would still require programming the programming language in the programming language, which seems kind of ridiculous. So, I thought that perhaps just writing machine code would be useful, but machine code is still confusing and just writing it directly wouldn’t allow for writing a program that works on different CPU architectures (and tbh I want it to work for synthetic biology too, but maybe that’s crazy). Currently, I’m enjoying using Neovim for normal programming which gives you a bunch of fun keyboard commands to manipulate things and a fully traversable edit history even with custom macros and command. Thinking about: "why can’t one make a similar environment for machine code?", "Why can’t one make a similar environment that is output format agnostic?". I think I can.</p>
	<p>I started making this in Flutter, but it’s not a high priority. It almost minimally works, though. Still not sure if this makes any sense.</p>
<h2>Some way to simulate proteins accurately and quickly without a supercomputer or statistical AI</h2>
	<p>I believe that there must be some way to simulate proteins accurately and quickly without supercomputer-scale computation power because that would be sad. Learning about other physics experiments before computers, they always had some kind of unique way to model things using physics instead of digital computer algorithms. I think that part of the issue with current efforts to create simulations is an addiction to computer algorithms that are only capable of digital manipulations that suffer from both syncing and locality issues.</p>
	<p>From what I understand, the hard part of protein simulation is simulating the electric (and other field forces) fields that move the particles and their fields about. So, my current working idea is to create something like a "FiPU (Field Processing Unit)" that creates real fields (like, in real life) and measures them (like, in real life) as an accelerator card like GPUs (Graphical Processing Units). However, I worry that I don’t know computer engineering well, don’t have access to semiconductor factories, that it may have to be huge, and that it may not make any sense.</p>
<h2>Solve Aging</h2>
	<p>All of the above projects and me going for a bioengineering degree somehow aid in this project. The blog helps me think and get out of my personal thought bubble, the learning app makes me smarter, the workspace app will hopefully allow simpler design of the required biomolecules, and the simulations will allow those biomolecules to be quickly iteratively tested.</p>
	<p>I want to solve aging because success will theoretically give me at least some multiples of the current expected time I have to do fun things. If you think aging and death somehow gives value to life, I think you’re just coping (unless it's a religious thing). To be extra clear, when I say "solving aging" I mean "getting rid of and/or reversing age-related deterioration", not "stopping and/or reversing maturing".</p>
